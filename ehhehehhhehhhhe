/*
 Judah Small

 CS2060-001 (TTh)

 OS: Windows [&macOS (current iteration has been passed back and forth between the 2 and seems to work in both environments (final compile was windows))]

 Iteration 2

 Due: 04/30/2022

 Description: This is a current iteration of my ticket sales project this
 itteration encompasses all user story requirements. the program
 includes a limited access and limited attempt admin setup sequence that validates a pin, assigns the charity percentage, and prices for each
 seat type. The validation of the completion of this sequence lets main decide if it should continue on to a ticket sales mode. The ticket sales
 mode allows customers to select a seat type (and validate their choice), the number of tickets they want (and validate their choice), enter a
 zipcode to "validate a credit card", decide if they want a receipt, and allows for the escape at any moment by the entry of a q. if a q is entered the admin pin must be validated within
 the limited attempts or the program will re-enter the sales mode. If a successful quit is validated the admin print displays all of the information entered
 by the customers (ie. number of tickets sold for each type, total sold, total sales, total donated.
 */

#include <stdlib.h> //including of librairies for functions needed
#include <stdio.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>

#define DOUBLE_LENGTH 7
#define STRING_MAX  50
#define PATH_LENGTH 100
#define ADMIN_PIN 4932 //admin pin
#define CHARITY_MIN 10.0 //min percentage
#define CHARITY_MAX 30.0 //max percentage
#define PRICE_MAX 500.00
#define PRICE_MIN 10.00
#define ZIP_LENGTH 5
#define CHAR_LENGTH 1
#define CURRENCY_TYPE "$"
#define ZIP_MIN 00000
#define ZIP_MAX 99999
#define ADMIN_TRIES 4 //number of tries admin has to enter pin
#define CHARITY_EVENT "charity" //name of charity
#define EVENT_NAME "Denver Nuggets Game" //name of event


//need to include double max and min
// errno ?

const char* SALES_FILE = "salesSummary.txt";
const char* RECEIPT_FILE = "receipt.txt";
const char* DIRECTORY_PATH = "/Users/JudeRamone/ticketSales/";
const char* HAL_MESSAGE = "I'm sorry Dave, I'm afraid I can't do that...";


typedef struct seatName
{
    char name[STRING_MAX]; //Name for seat type
    char sigChar[STRING_MAX]; //signal character
    double price;
    int numOTix;
    double sales;
    double raisedForCharity;
    struct seatName* nextLevel;
    
}SEAT;


//done
bool getInfo(char* inputStr);
int intConvert(char* inputStr); // maybe try and make const
bool rangeCheck(double receivedNo, double min, double max);
bool zipValidate(const char* input, int zipEntry);
bool charValidate(const char* input);
double stringToDouble(char* inputStr);
void adminSetup(SEAT** headPtr, int noSeatTypes, char* inputStr, double* charityPercent);

bool adminPinValidate(char* inputStr);
// done but not tested\|/
void getFilePath(char* finalPath, const char* directoryPath, const char* fileName);
bool w_or_a_ToFile(const char* formatedList, const char* filePath, char signal);// possibly be better to just pass the head of a linked list!!!!


void userSeatInfo(SEAT* signalOrderedPtr);

// what needs to be done


void getSigChar(SEAT **headPtr); // look up some more double ptr info so that i can be more comfortable with their overall efficacy //this will go in either user or admin area
//users function
    // store values of user for receipt in primitive data


int main(void)
{
    bool pinSuccess= false;
    bool seatNumber = false;
    int noSeatLevels = 0;
    char input[STRING_MAX] = {'\0' };
    SEAT* headPtr= NULL;
    double charityPerc = 0.0;
   // char summaryPath[PATH_LENGTH] = {'\0'};
   // char receiptPath[PATH_LENGTH] = {'\0'};
    pinSuccess=(adminPinValidate(input));
    
    if (pinSuccess == true)
    {
        while(seatNumber == false)
        {
            puts("Hello Dave, how many seat levels are needed for the event?");
            noSeatLevels=(intConvert(input));
            if(noSeatLevels != -99)
            {
                seatNumber = true;
            }
            else
            {
                puts("Please try again");
            }
        }
        adminSetup(&headPtr, noSeatLevels, input, &charityPerc);
    }
    puts("\nWelcome to HAL's ticket Sales!\n");
    
    userSeatInfo(headPtr);

    puts("This program can serve no purpose anymore, Goodbye.");
    return 0;
}

void getFilePath(char* finalPath, const char* directoryPath, const char* fileName)
{
    strcpy(finalPath, directoryPath);
    strcat(finalPath, fileName);
}

bool w_or_a_ToFile( const char* formattedList, const char* filePath, char signal) //signal if wanting to write follow w signal path if wanting to append follow a signalpath
{
    FILE* saleFile;
    bool wORa = false; //able to write or append
    
    if (signal == 'w')
    {
        if ((saleFile = fopen(filePath, "w")) == NULL)
        {
            puts(HAL_MESSAGE);
            puts("file could not be written");
        }
        else
        {
            wORa=true;
            puts("Generating Sales Report...");
            //use sprintf fputs// is there a function that will allow multiple outputs? ie tee in linux sadly not that i have found so far
            //print salessummary specific headers to file
            //print total info
        }
    }
    
    else if (signal == 'a')
    {
        if ((saleFile = fopen(filePath, "a")) == NULL) //if the file does not exist
        {
            puts(HAL_MESSAGE);
            puts("file does not exist"); //would you like to create one? would need to pass directory info
        }
        else
        {
            wORa= true;
            puts("Generating Reciept...");
            //use sprintf fputs// is there a function that will allow multiple outputs? ie tee in linux sadly not that i have found so far
            //print reciept specific headers to console and file
            //print user specific info
        }
    }
    
    else //read case signal would be r  ////////not necessary just trying to catch or think about how it could be utilized at a later time
    {
        if ((saleFile = fopen(filePath, "r")) == NULL) //if the file does not exist
        {
            puts(HAL_MESSAGE);
            puts("file can not be read"); //would you like to create one? would need to pass directory info
        }
        
    }
    
    return wORa;
}

bool adminPinValidate(char* inputStr)
{
    bool pinSuccess = false;
    int pinEntered = 0;
    
    for (size_t i= 0; i < ADMIN_TRIES; i++)
    {
        puts("Enter ADMIN pin to continue");
        pinEntered = (intConvert(inputStr));
        
        if (pinEntered == ADMIN_PIN)
        {
            pinSuccess = true;
            i = ADMIN_TRIES;
        }
        
        else if(pinEntered == -99)
        {
            printf("You have %d tries remaining\n", ((int)(ADMIN_TRIES - (i+1))));
        }
        
        else
        {
            puts(HAL_MESSAGE);
            puts("Your access code is invalid");
            printf("You have %d tries remaining\n", ((int)(ADMIN_TRIES - (i+1))));
        }
    }
    
    if(pinSuccess==false)
    {
        puts(HAL_MESSAGE);
        puts("This mission is too important for me to allow you to jeopordize it.");
    }
    
    return pinSuccess;
}

bool zipValidate(const char* input, int zipEntry)
{
    bool validZip = false;
    int length = 0;
    
    length = (int)strlen(input);
    
    if(length != ZIP_LENGTH)
    {
        puts(HAL_MESSAGE);
        puts("wrong number of characters");
    }
    
    else
    {
        validZip = (rangeCheck(zipEntry, ZIP_MIN, ZIP_MAX));
    }
    
    return validZip;
}

bool charValidate(const char* input)
{
    bool validChar = false;
    int length = 0;
    
    length = (int)strlen(input);
    
    if(length != CHAR_LENGTH)
    {
        puts(HAL_MESSAGE);
        puts("Not a single character");
    }
    else
    {
        validChar = true;
    }
    
    return validChar;
}

bool rangeCheck(double receivedNo, double min, double max)
{
    bool inRange = false;
    
    if((min <= receivedNo) && (max >= receivedNo))
    {
        inRange=true;
    }
    
    else
    {
        puts("Entry out of range");
    }
    return inRange;
}


int intConvert(char* input) // can i make this constant somehow
{
    bool strictInt(double convertedDouble);
    
    bool validInt = false;
    double doubledString = 0.0;
    int convertedInt = -99;

    doubledString =(stringToDouble(input));
    
    if (doubledString != -99.9)
    {
        validInt =(strictInt(doubledString));
    
        if (validInt == true)
        {
            convertedInt=((int)doubledString);
        }
    }
    
    else
    {
        puts("Invalid numerical information supplied");
    }
    
    return convertedInt;
}

bool strictInt(double convertedDouble) //possibly pass the address of int to be modified and it only modifies if it passes the test or do that in main
{
    bool success = false;
    double conversion = -99.9;
    
    if(convertedDouble != 0.0)
    {
        conversion = (convertedDouble/((int)convertedDouble));
        if (conversion == 1)
        {
            success = true;
        }
        else
        {
            puts(HAL_MESSAGE);
            puts("Number is not a whole integer");
        }
    }
    else //takes care of 0 case
    {
        success = true;
    }
    return success;
}

bool getInfo(char* inputStr)
{
    bool successful = false;
    
    successful=(fgets(inputStr, STRING_MAX, stdin));
    
    for (size_t i = 0; i <= STRING_MAX; i++)
    {
       if (inputStr[i] == '\n')
        {
           inputStr[i] = '\0';
            i = STRING_MAX;
        }
        
    }
    return successful;
}

double stringToDouble(char* inputStr)
{
    bool getInputSuccess = false;
    double value = -99.9;
    char* remaining = NULL;
    
    getInputSuccess=(getInfo(inputStr));
    
    if(getInputSuccess == true)
    {
        double conversion = strtod(inputStr, &remaining);
    
        if(remaining == inputStr) // if the double is null
        {
            puts(HAL_MESSAGE);
            puts("No valid entry was made");
        }
        else if (*remaining != '\0')
        {
            puts(HAL_MESSAGE);
            puts("invalid entry");
        }
    
        else if((LONG_MIN < conversion) && (LONG_MAX > conversion))
        {
            value = conversion;
        }
    
        else
        {
            puts(HAL_MESSAGE);
            puts("invalid entry range error");
        }
    }
    
    else
    {
        puts(HAL_MESSAGE);
        puts("Unable to get input");
    }
    
    return value;
}

void insertLevel(SEAT** headPtr, const char* seatLevel, const char* signal, double price) // will be called in admin func
{
    SEAT* levelPtr = malloc(sizeof(SEAT));
    
    if (levelPtr != NULL)
    {
        strcpy(levelPtr->name, seatLevel);
        strcpy(levelPtr->sigChar, signal);
        levelPtr->price = price;
        levelPtr->numOTix = 0 ;
        levelPtr->sales = 0;
        levelPtr->raisedForCharity = 0;
        levelPtr->nextLevel = NULL;
        SEAT* previousLevel = NULL;
        SEAT* currentLevel = *headPtr;
    
        while ((currentLevel != NULL) && (strcmp(currentLevel->sigChar, signal) < 0))
        {
            previousLevel = currentLevel;
            currentLevel = currentLevel->nextLevel;
        }
    
        if(previousLevel == NULL)
        {
            *headPtr = levelPtr;
        }
        
        else
        {
            previousLevel->nextLevel = levelPtr;
        }
        
        levelPtr->nextLevel = currentLevel;
    }
    
    else
    {
        puts(HAL_MESSAGE);
        puts("Not enough memory allocated");
    }
}

void adminSetup(SEAT** headPtr, int noSeatTypes, char* inputStr, double* charityPercent)
{
    double price = 0.0;
    double charity =0.0;
    char seatLevel[STRING_MAX] = {'\0'};
    char signalChar[STRING_MAX] = {'\0'};
    bool charitySuccess = false;
    
    void insertLevel(SEAT** headPtr, const char* seatLevel, const char* signal, double price);
    void adminSeatInfo(SEAT* signalOrderedPtr);
    
    while(charitySuccess == false)  //get valid charity percent that is updated in main check to see if less than 1 and if so multiply by 100 before sending to range check
    {
        printf("Please enter the percentage of sales donated to charity %.2lf-%.2lf\n", CHARITY_MIN, CHARITY_MAX);
        charity=(stringToDouble(inputStr));
        
        if(charity <= 1.0)
        {
            charity*=100;
        }
        
        charitySuccess=(rangeCheck(charity, CHARITY_MIN, CHARITY_MAX));
        if (charitySuccess == false)
        {
            puts("Please try another value");
            
        }
    }

    for (size_t i= 0; i < noSeatTypes; i++)
    {
        bool seatNameSuccess = false;
        bool setPriceSuccess = false;
        bool setCharSuccess = false;
        
        printf("You have %d seat types to setup\n", ((int)(noSeatTypes - i)));
        while (seatNameSuccess == false)
        {
            puts("Enter a Seat Level Name to include:");
            seatNameSuccess=(getInfo(seatLevel));
            if (seatNameSuccess == false)
            {
                puts("Please try again.");
            }
        }
        seatLevel[0]=toupper(seatLevel[0]);
        
        while (setCharSuccess == false)
        {
            puts("Enter a signal for this seat level in Sales mode:");
            setCharSuccess=((getInfo(signalChar)) && (charValidate(signalChar)));
        }
        signalChar[0]=toupper(signalChar[0]);
        
        while (setPriceSuccess == false)
        {
            printf("Please enter the ticket price for these seats %s%.2lf-%s%.2lf\n", CURRENCY_TYPE, PRICE_MIN, CURRENCY_TYPE, PRICE_MAX);
            price=(stringToDouble(inputStr));
            setPriceSuccess=(rangeCheck(price, PRICE_MIN, PRICE_MAX));
        }
        
        insertLevel(headPtr, seatLevel, signalChar, price);
    }
    
    insertLevel(headPtr, "Total Sales", "Z", 0);
    
    adminSeatInfo(*headPtr);
    
    puts("Dave, I have successfully compiled the information and can begin sales mode.");
    
}

void adminSeatInfo(SEAT* signalOrderedPtr)
{
    if(signalOrderedPtr != NULL)
    {
        puts("Dave, the seat levels are:");
        SEAT* currentLevel = signalOrderedPtr;
        
        while (currentLevel != NULL)
        {
            printf("Name: %s\nSignal: %s\nPrice: %s%.2lf\nNumber of Tickets: %d\nTotal Sales: %s%.2lf\nRaised for charity: %s%.2lf\n\n", currentLevel->name, currentLevel->sigChar, CURRENCY_TYPE, currentLevel->price, currentLevel->numOTix, CURRENCY_TYPE, currentLevel->sales, CURRENCY_TYPE, currentLevel->raisedForCharity);
            currentLevel = currentLevel->nextLevel;
        }
    }
    else
    {
        puts(HAL_MESSAGE);
        puts("There is no information to print");
    }
}

void userSeatInfo(SEAT* signalOrderedPtr)
{
    if(signalOrderedPtr != NULL)
    {
        puts("The available seat levels are:");
        SEAT* currentLevel = signalOrderedPtr;
        
        while (currentLevel->nextLevel != NULL)
        {
            printf("%s (%s) %s%.2lf\n", currentLevel->name, currentLevel->sigChar, CURRENCY_TYPE, currentLevel->price);
            currentLevel = currentLevel->nextLevel;
        }
    }
    else
    {
        puts(HAL_MESSAGE);
        puts("There is no information to print");
    }
}
