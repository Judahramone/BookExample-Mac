/*
 Judah Small

 CS2060-001 (TTh)

 OS: Windows [&macOS (current iteration has been passed back and forth between the 2 and seems to work in both environments (final compile was windows))]

 Iteration 2

 Due: 04/30/2022

 Description: This is a current iteration of my ticket sales project this
 itteration encompasses all user story requirements. the program
 includes a limited access and limited attempt admin setup sequence that validates a pin, assigns the charity percentage, and prices for each
 seat type. The validation of the completion of this sequence lets main decide if it should continue on to a ticket sales mode. The ticket sales
 mode allows customers to select a seat type (and validate their choice), the number of tickets they want (and validate their choice), enter a
 zipcode to "validate a credit card", decide if they want a receipt, and allows for the escape at any moment by the entry of a q. if a q is entered the admin pin must be validated within
 the limited attempts or the program will re-enter the sales mode. If a successful quit is validated the admin print displays all of the information entered
 by the customers (ie. number of tickets sold for each type, total sold, total sales, total donated.
 */

#include <stdlib.h> //including of librairies for functions needed
#include <stdio.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>

#define YN 2
#define PACKAGETYPES 4
#define DOUBLE_LENGTH 7
#define STRING_MAX  50
#define PATH_LENGTH 100
#define SUMMARY_MAX 500
#define ADMIN_PIN 4932 //admin pin
#define CHARITY_MIN 10.0 //min percentage
#define CHARITY_MAX 30.0 //max percentage
#define PRICE_MAX 500.00
#define PRICE_MIN 10.00
#define ZIP_LENGTH 5
#define CHAR_LENGTH 1
#define CURRENCY_TYPE "$"
#define ZIP_MIN 00000
#define ZIP_MAX 99999
#define ADMIN_TRIES 4 //number of tries admin has to enter pin
#define CHARITY_EVENT "Charity" //name of charity
#define EVENT_NAME "Denver Nuggets Game" //name of event
#define QUIT "Quit"


//need to include double max and min
// errno ?

const char* YNarray[] = { "N", "Y" };
const int PACKAGES[] = { 1, 2, 3, 4 };
const char* PACKAGENAMES[] = { "Single Pack", "Double Pack", "Triple Pack", "Family Pack" };
const char* SALES_FILE = "salesSummary.txt";
const char* RECEIPT_FILE = "receipt.txt";
const char* DIRECTORY_PATH = "/Users/JudeRamone/ticketSales/";
const char* HAL_MESSAGE = "I'm sorry Dave, I'm afraid I can't do that...";


typedef struct seatName
{
    char name[STRING_MAX]; //Name for seat type
    char sigChar[STRING_MAX]; //signal character
    double price;
    int numOTix;
    double sales;
    double raisedForCharity;
    struct seatName* nextLevel;
    
}SEAT;


//done
bool getInfo(char* inputStr);
int intConvert(char* inputStr); // maybe try and make const
bool rangeCheck(double receivedNo, double min, double max);
bool zipValidate(const char* input, int zipEntry);
bool charValidate(const char* input);
double stringToDouble(char* inputStr);
void adminSetup(SEAT** headPtr, int noSeatTypes, char* inputStr, double* charityPercent);
void getFilePath(char* finalPath, const char* directoryPath, const char* fileName);
bool adminPinValidate(char* inputStr);
double charCalc(double cost, double charPerc);
double tixCalc(double tixPrice, double numOTix);


// done but not tested\|/
bool w_or_a_ToFile(const char* formatedList, const char* filePath, char signal);// possibly be better to just pass the head of a linked list!!!!
bool yesNo (char* entry);


int main(void)
{
    bool pinSuccess= false;
    bool seatNumber = false;
    int noSeatLevels = 0;
    char input[STRING_MAX] = {'\0' };
    SEAT* headPtr= NULL;
    double charityPerc = 0.0;
    char summaryPath[PATH_LENGTH] = {'\0'};
    char receiptPath[PATH_LENGTH] = {'\0'};
    
    getFilePath(summaryPath, DIRECTORY_PATH, SALES_FILE);
    getFilePath(receiptPath, DIRECTORY_PATH, RECEIPT_FILE);
    
    pinSuccess=(adminPinValidate(input));
    
    if (pinSuccess == true)
    {
        while(seatNumber == false)
        {
            puts("Hello Dave, how many seat levels are needed for the event?");
            noSeatLevels=(intConvert(input));
            if(noSeatLevels != -99)
            {
                seatNumber = true;
            }
            else
            {
                puts("Please try again");
            }
        }
        adminSetup(&headPtr, noSeatLevels, input, &charityPerc);
    }

    puts("This program can serve no purpose anymore, Goodbye.");
    return 0;
}

void getFilePath(char* finalPath, const char* directoryPath, const char* fileName)
{
    strcpy(finalPath, directoryPath);
    strcat(finalPath, fileName);
}

bool w_or_a_ToFile( const char* formattedList, const char* filePath, char signal) //signal if wanting to write follow w signal path if wanting to append follow a signalpath
{
    FILE* saleFile;
    bool wORa = false; //able to write or append
    
    if (signal == 'w')
    {
        if ((saleFile = fopen(filePath, "w")) == NULL)
        {
            puts(HAL_MESSAGE);
            puts("file could not be written");
        }
        else
        {
            wORa=true;
            puts("Generating Sales Report...");
            //use sprintf fputs// is there a function that will allow multiple outputs? ie tee in linux sadly not that i have found so far
            //print salessummary specific headers to file
            //print total info
        }
    }
    
    else if (signal == 'a')
    {
        if ((saleFile = fopen(filePath, "a")) == NULL) //if the file does not exist
        {
            puts(HAL_MESSAGE);
            puts("file does not exist"); //would you like to create one? would need to pass directory info
        }
        else
        {
            wORa= true;
            puts("Generating Receipt...");
            //use sprintf fputs// is there a function that will allow multiple outputs? ie tee in linux sadly not that i have found so far
            //print reciept specific headers to console and file
            //print user specific info
        }
    }
    
    else //read case signal would be r  ////////not necessary just trying to catch or think about how it could be utilized at a later time
    {
        if ((saleFile = fopen(filePath, "r")) == NULL) //if the file does not exist
        {
            puts(HAL_MESSAGE);
            puts("file can not be read"); //would you like to create one? would need to pass directory info
        }
        
    }
    
    return wORa;
}

bool adminPinValidate(char* inputStr)
{
    bool pinSuccess = false;
    int pinEntered = 0;
    
    for (size_t i= 0; i < ADMIN_TRIES; i++)
    {
        puts("Enter ADMIN pin to continue");
        pinEntered = (intConvert(inputStr));
        
        if (pinEntered == ADMIN_PIN)
        {
            pinSuccess = true;
            i = ADMIN_TRIES;
        }
        
        else if(pinEntered == -99)
        {
            printf("You have %d tries remaining\n", ((int)(ADMIN_TRIES - (i+1))));
        }
        
        else
        {
            puts(HAL_MESSAGE);
            puts("Your access code is invalid");
            printf("You have %d tries remaining\n", ((int)(ADMIN_TRIES - (i+1))));
        }
    }
    
    if(pinSuccess==false)
    {
        puts(HAL_MESSAGE);
        puts("This mission is too important for me to allow you to jeopordize it.");
    }
    
    return pinSuccess;
}

bool zipValidate(const char* input, int zipEntry)
{
    bool validZip = false;
    int length = 0;
    
    length = (int)strlen(input);
    
    if(length != ZIP_LENGTH)
    {
        puts(HAL_MESSAGE);
        puts("wrong number of characters");
    }
    
    else
    {
        validZip = (rangeCheck(zipEntry, ZIP_MIN, ZIP_MAX));
    }
    
    return validZip;
}

bool charValidate(const char* input)
{
    bool validChar = false;
    int length = 0;
    
    length = (int)strlen(input);
    
    if(length != CHAR_LENGTH)
    {
        puts(HAL_MESSAGE);
        puts("Not a single character");
    }
    else
    {
        validChar = true;
    }
    
    return validChar;
}

bool rangeCheck(double receivedNo, double min, double max)
{
    bool inRange = false;
    
    if((min <= receivedNo) && (max >= receivedNo))
    {
        inRange=true;
    }
    
    else
    {
        puts("Entry out of range");
    }
    return inRange;
}


int intConvert(char* input) // can i make this constant somehow
{
    bool strictInt(double convertedDouble);
    
    bool validInt = false;
    double doubledString = 0.0;
    int convertedInt = -99;

    doubledString =(stringToDouble(input));
    
    if (doubledString != -99.9)
    {
        validInt =(strictInt(doubledString));
    
        if (validInt == true)
        {
            convertedInt=((int)doubledString);
        }
    }
    
    else
    {
        puts("Invalid numerical information supplied");
    }
    
    return convertedInt;
}

bool strictInt(double convertedDouble) //possibly pass the address of int to be modified and it only modifies if it passes the test or do that in main
{
    bool success = false;
    double conversion = -99.9;
    
    if(convertedDouble != 0.0)
    {
        conversion = (convertedDouble/((int)convertedDouble));
        if (conversion == 1)
        {
            success = true;
        }
        else
        {
            puts(HAL_MESSAGE);
            puts("Number is not a whole integer");
        }
    }
    else //takes care of 0 case
    {
        success = true;
    }
    return success;
}

bool getInfo(char* inputStr)
{
    bool successful = false;
    
    successful=(fgets(inputStr, STRING_MAX, stdin));
    
    for (size_t i = 0; i <= STRING_MAX; i++)
    {
       if (inputStr[i] == '\n')
        {
           inputStr[i] = '\0';
            i = STRING_MAX;
        }
        
    }
    return successful;
}

double stringToDouble(char* inputStr)
{
    bool getInputSuccess = false;
    double value = -99.9;
    char* remaining = NULL;
    
    getInputSuccess=(getInfo(inputStr));
    
    if(getInputSuccess == true)
    {
        double conversion = strtod(inputStr, &remaining);
    
        if(remaining == inputStr) // if the double is null
        {
            puts(HAL_MESSAGE);
            puts("No valid entry was made");
        }
        else if (*remaining != '\0')
        {
            puts(HAL_MESSAGE);
            puts("invalid entry");
        }
    
        else if((LONG_MIN < conversion) && (LONG_MAX > conversion))
        {
            value = conversion;
        }
    
        else
        {
            puts(HAL_MESSAGE);
            puts("invalid entry range error");
        }
    }
    
    else
    {
        puts(HAL_MESSAGE);
        puts("Unable to get input");
    }
    
    return value;
}

void insertLevel(SEAT** headPtr, const char* seatLevel, const char* signal, double price) // will be called in admin func
{
    SEAT* levelPtr = malloc(sizeof(SEAT));
    
    if (levelPtr != NULL)
    {
        strcpy(levelPtr->name, seatLevel);
        strcpy(levelPtr->sigChar, signal);
        levelPtr->price = price;
        levelPtr->numOTix = 0 ;
        levelPtr->sales = 0;
        levelPtr->raisedForCharity = 0;
        levelPtr->nextLevel = NULL;
        SEAT* previousLevel = NULL;
        SEAT* currentLevel = *headPtr;
    
        while ((currentLevel != NULL) && (strcmp(currentLevel->sigChar, signal) < 0))
        {
            previousLevel = currentLevel;
            currentLevel = currentLevel->nextLevel;
        }
    
        if(previousLevel == NULL)
        {
            *headPtr = levelPtr;
        }
        
        else
        {
            previousLevel->nextLevel = levelPtr;
        }
        
        levelPtr->nextLevel = currentLevel;
    }
    
    else
    {
        puts(HAL_MESSAGE);
        puts("Not enough memory allocated");
    }
}

void adminSetup(SEAT** headPtr, int noSeatTypes, char* inputStr, double* charityPercent)
{
    double price = 0.0;
    double charity =0.0;
    char seatLevel[STRING_MAX] = {'\0'};
    char signalChar[STRING_MAX] = {'\0'};
    bool charitySuccess = false;
    
    void insertLevel(SEAT** headPtr, const char* seatLevel, const char* signal, double price);
    void adminSeatInfo(SEAT* signalOrderedPtr);
    
    while(charitySuccess == false)  //get valid charity percent that is updated in main check to see if less than 1 and if so multiply by 100 before sending to range check
    {
        printf("Please enter the percentage of sales donated to charity %.2lf-%.2lf\n", CHARITY_MIN, CHARITY_MAX);
        charity=(stringToDouble(inputStr));
        
        if(charity <= 1.0)
        {
            charity*=100;
        }
        
        charitySuccess=(rangeCheck(charity, CHARITY_MIN, CHARITY_MAX));
        if (charitySuccess == false)
        {
            puts("Please try another value");
            
        }
    }

    for (size_t i= 0; i < noSeatTypes; i++)
    {
        bool seatNameSuccess = false;
        bool setPriceSuccess = false;
        bool setCharSuccess = false;
        
        printf("You have %d seat types to setup\n", ((int)(noSeatTypes - i)));
        while (seatNameSuccess == false)
        {
            puts("Enter a Seat Level Name to include:");
            seatNameSuccess=(getInfo(seatLevel));
            if (seatNameSuccess == false)
            {
                puts("Please try again.");
            }
        }
        seatLevel[0]=toupper(seatLevel[0]);
        
        while (setCharSuccess == false)
        {
            puts("Enter a signal for this seat level in Sales mode:");
            setCharSuccess=((getInfo(signalChar)) && (charValidate(signalChar)));
        }
        signalChar[0]=toupper(signalChar[0]);
        
        while (setPriceSuccess == false)
        {
            printf("Please enter the ticket price for these seats %s%.2lf-%s%.2lf\n", CURRENCY_TYPE, PRICE_MIN, CURRENCY_TYPE, PRICE_MAX);
            price=(stringToDouble(inputStr));
            setPriceSuccess=(rangeCheck(price, PRICE_MIN, PRICE_MAX));
        }
        
        insertLevel(headPtr, seatLevel, signalChar, price);
    }
    
    insertLevel(headPtr, "Total Sales", "Z", 0);
    
    adminSeatInfo(*headPtr);
    
    puts("Dave, I have successfully compiled the information and can begin sales mode.");
    
}

void adminSeatInfo(SEAT* signalOrderedPtr)
{
    if(signalOrderedPtr != NULL)
    {
        puts("\nDave, the seat levels are:");
        SEAT* currentLevel = signalOrderedPtr;
        
        while (currentLevel != NULL)
        {
            printf("Name: %s\nSignal: %s\nPrice: %s%.2lf\nNumber of Tickets: %d\nTotal Sales: %s%.2lf\nRaised for charity: %s%.2lf\n\n", currentLevel->name, currentLevel->sigChar, CURRENCY_TYPE, currentLevel->price, currentLevel->numOTix, CURRENCY_TYPE, currentLevel->sales, CURRENCY_TYPE, currentLevel->raisedForCharity);
            currentLevel = currentLevel->nextLevel;
        }
    }
    else
    {
        puts(HAL_MESSAGE);
        puts("There is no information to print");
    }
}

void userSeatInfo(SEAT* signalOrderedPtr, double charityPerc)
{
    if(signalOrderedPtr != NULL)
    {
        puts("The available seat levels are:");
        SEAT* currentLevel = signalOrderedPtr;
        
        while (currentLevel->nextLevel != NULL)
        {
            printf("%s (%s) %s%.2lf\n", currentLevel->name, currentLevel->sigChar, CURRENCY_TYPE, currentLevel->price);
            currentLevel = currentLevel->nextLevel;
        }
        printf("%.2lf percent of your tickets purchased will be donated to %s", charityPerc, CHARITY_EVENT);
    }
    else
    {
        puts(HAL_MESSAGE);
        puts("There are no available seats for purchase");
    }
}

void userReceiptFormat(char* userString, int userNumTix, SEAT* levelSelected, double totalPrice, double donation, double charityPercent)
{
    
    sprintf(userString, "%s Ticket Sale Receipt\n\n%s x %d @ %s %.2lf/nYour total is: %.2lf\n %.2lf percent of your sales (%s%.2lf) was donated to %s\n THANK YOU FOR YOUR PURCHASE\n\n", EVENT_NAME, levelSelected->name, userNumTix, CURRENCY_TYPE, levelSelected->price, totalPrice, charityPercent, CURRENCY_TYPE, donation, CHARITY_EVENT);
    
}

void adminSalesSummaryFormat(SEAT* headPtr, char* salesString, double charityPercent)
{
    
}

SEAT* levelFound(SEAT* headPtr, const char* signal)
{
    SEAT* previousLevel = NULL;
    SEAT* currentLevel = headPtr;
    
    if((strcmp(currentLevel->sigChar, signal)) == 0)
    {
        //first seat type
    }
    else
    {
        previousLevel = headPtr;
        currentLevel = headPtr->nextLevel;
        
        while((currentLevel != NULL) && (strcmp(currentLevel->sigChar, signal)) != 0)
        {
            previousLevel = currentLevel;
            currentLevel = currentLevel->nextLevel;
        }
        
        if(currentLevel == NULL)
        {
            printf("'%s' is not a valid seat signal\n", signal);
        }
    }
    return currentLevel;
}

bool salesMode(SEAT* headPtr, double charityPerc)
{
    bool quit = false;
    bool pinSuccess= false;
    bool readInput = false;
    bool validSelection = false;
    bool singleChar = false;
    int userTickets = 0;
    SEAT* userLevel = NULL;
    char selection[STRING_MAX] = {'\0'};
    
    void userSeatInfo(SEAT* signalOrderedPtr, double charityPerc);
    int packageSelect(void);
    
    printf("\nWelcome to HAL's %s %s ticket Sales!\n", EVENT_NAME, CHARITY_EVENT);
    
    while((quit == false) || (validSelection == false))
    {
        userSeatInfo(headPtr, charityPerc);
        readInput = (getInfo(selection));
        if (readInput == true)
        {
            if(strcmp(selection, QUIT) == 0)
            {
                pinSuccess=(adminPinValidate(selection));
                if(pinSuccess == true)
                {
                    quit = true;
                }
                else
                {
                    puts(HAL_MESSAGE);
                    puts("This mission is too important for me to allow you to jeopordize it.");
                }
            }
            else
            {
                selection[0]=toupper(selection[0]);
                singleChar=(charValidate(selection));
                if (singleChar == true)
                {
                    userLevel =(levelFound(headPtr, selection));
                    if (userLevel != NULL)
                    {
                        printf("You have selected %s, do you wish to continue?", userLevel->name);
                        
                        validSelection = yesNo(selection);
                    }
                    else
                    {
                        puts("Please try again");
                    }
                }
                else
                {
                    puts("Please try again");
                }
            }
        }
    }
    
    if(quit == false)
    {
        userTickets = (packageSelect());
        // update linked list info
        // ask for receipt
    }
    else
    {
        // create sum of tickets
        //update sales info per seat and total
        // update donation per seat and total
        //
        
    }
    return quit;
    
}


double tixCalc(double tixPrice, double numOTix) // calculates total amount of tickets by having the ticket price and number of tickets multiplied together
{
   double totalPrice = 0.0;

   totalPrice = tixPrice * numOTix;

   return totalPrice;

}

double charCalc(double cost, double charPerc) // calculates the amount donated takes the charity percent and the cost and calculates what will be donated
{
    double whatsDonated = 0.0;

    whatsDonated = cost * (charPerc /100);

    return whatsDonated;
}

int packageSelect(void)
{
    int package = 0;
    int packageVal = 0;
    bool confirmed = false;
    char packageSelect[STRING_MAX] = {'\0'};
    char ynSelect[STRING_MAX] = {'\0'};

    while(confirmed == false)
    {
        bool validType = 0;
        while (validType == false) // only breaks when a valid entry has been made and confirmed
        {
            puts("Package options are: ");
            for (size_t i = 0; i < PACKAGETYPES; i++)
            {
                printf("%d%s\t%s\n", PACKAGES[i], ")", PACKAGENAMES[i]); //prints prices next to each seattype
            }

            puts("Enter your package selection:");
            package = (intConvert(packageSelect));
        
            if(package == -99)
            {
                puts("Not an acceptable selection");
            }
        
            else
            {
                for (int i = 0; i < PACKAGETYPES; i++)
                {
                    if (package == PACKAGES[i])  //loops through the entire array checking for equivalency at each index of the array
                    {
                        packageVal = (i+1); // takes the value of the index that was equivalent
                        i = PACKAGETYPES;  //sets it to the end of the array in order for the loop to end once the value has found equivalency
                    }
                }
                if (packageVal != 0)
                {
                    validType = true;
                }
                else
                {
                    puts("Not an available package type");
                }
            
            }
        }
        printf("You have selected the %s do you wish to continue?\n", PACKAGENAMES[(packageVal-1)]);
        
        confirmed=(yesNo(ynSelect));

    }

    return packageVal; //returns value of what array element was matched in either array
}

bool yesNo (char* entry)
{
    bool validChar = false;
    bool validYN = false;
    bool yN = false;
    
    while (validYN == false)
    {
        puts("Enter Y or N");
        validChar=((getInfo(entry))&&(charValidate(entry)));
        if(validChar == false)
        {
            puts("Please try again");
        }
        else if(strcmp(entry, YNarray[1] ) == 0)
        {
            yN=true;
            validYN = true;
        }
        else if(strcmp(entry, YNarray[0] ) == 0)
        {
            puts("Returning to selection options...");
            yN=false;
            validYN = true;
        }
        else
        {
            puts("Please try again");
        }
    }

    return yN;
}
